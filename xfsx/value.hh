/**************************************************************************/
/*
   Autogenerated by the Variant Generator.

   Call was:

     '../variant-generator/build/mkvariant' 'value.inf' '--output' 'xfsx/value.cc'
                                                                          */
/**************************************************************************/
#ifndef VALUE_HH
#define VALUE_HH

#include <stdexcept>
#include <stdint.h>
#include <string>
#include <utility>

#include <xfsx/types.hh>
#include <xfsx/octet.hh>

namespace xfsx {

class Value {
  private:
    uint8_t tag_ {0};
    union {
      uint8_t uint8_t_;
      int8_t int8_t_;
      uint16_t uint16_t_;
      int16_t int16_t_;
      uint32_t uint32_t_;
      int32_t int32_t_;
      uint64_t uint64_t_;
      int64_t int64_t_;
      bool bool_;
      std::string std_string_;
      std::pair<const u8*, const u8*> std_pair_const_u8_const_u8__;
      std::pair<const char*, const char*> std_pair_const_char_const_char__;
      XML_Content xml_content_;
      BCD_Content bcd_content_;
      Int64_Content int64_content_;
    };
    void destruct();
  public:
    Value();
    Value(Value &&o);
    Value(const Value &o) =delete;
    Value(uint8_t o);
    Value(int8_t o);
    Value(uint16_t o);
    Value(int16_t o);
    Value(uint32_t o);
    Value(int32_t o);
    Value(uint64_t o);
    Value(int64_t o);
    Value(bool o);
    Value(std::string &&o);
    Value(std::pair<const u8*, const u8*> &&o);
    Value(std::pair<const char*, const char*> &&o);
    Value(XML_Content &&o);
    Value(BCD_Content &&o);
    Value(Int64_Content &&o);
    ~Value();

    Value &operator=(Value &&o);
    Value &operator=(const Value &o) =delete;
    Value &operator=(uint8_t o);
    Value &operator=(int8_t o);
    Value &operator=(uint16_t o);
    Value &operator=(int16_t o);
    Value &operator=(uint32_t o);
    Value &operator=(int32_t o);
    Value &operator=(uint64_t o);
    Value &operator=(int64_t o);
    Value &operator=(bool o);
    Value &operator=(std::string &&o);
    Value &operator=(std::pair<const u8*, const u8*> &&o);
    Value &operator=(std::pair<const char*, const char*> &&o);
    Value &operator=(XML_Content &&o);
    Value &operator=(BCD_Content &&o);
    Value &operator=(Int64_Content &&o);
    template <typename T> typename T::result_type apply(T &t)
    {
      switch (tag_) {
        case 1 : return t(uint8_t_);
        case 2 : return t(int8_t_);
        case 3 : return t(uint16_t_);
        case 4 : return t(int16_t_);
        case 5 : return t(uint32_t_);
        case 6 : return t(int32_t_);
        case 7 : return t(uint64_t_);
        case 8 : return t(int64_t_);
        case 9 : return t(bool_);
        case 10 : return t(std_string_);
        case 11 : return t(std_pair_const_u8_const_u8__);
        case 12 : return t(std_pair_const_char_const_char__);
        case 13 : return t(xml_content_);
        case 14 : return t(bcd_content_);
        case 15 : return t(int64_content_);
      }
      throw std::domain_error("variant not initialized");
    }

    template <typename T> typename T::result_type apply(const T &t)
    {
      switch (tag_) {
        case 1 : return t(uint8_t_);
        case 2 : return t(int8_t_);
        case 3 : return t(uint16_t_);
        case 4 : return t(int16_t_);
        case 5 : return t(uint32_t_);
        case 6 : return t(int32_t_);
        case 7 : return t(uint64_t_);
        case 8 : return t(int64_t_);
        case 9 : return t(bool_);
        case 10 : return t(std_string_);
        case 11 : return t(std_pair_const_u8_const_u8__);
        case 12 : return t(std_pair_const_char_const_char__);
        case 13 : return t(xml_content_);
        case 14 : return t(bcd_content_);
        case 15 : return t(int64_content_);
      }
      throw std::domain_error("variant not initialized");
    }

    template <typename T> typename T::result_type accept(T &t) const
    {
      switch (tag_) {
        case 1 : return t(uint8_t_);
        case 2 : return t(int8_t_);
        case 3 : return t(uint16_t_);
        case 4 : return t(int16_t_);
        case 5 : return t(uint32_t_);
        case 6 : return t(int32_t_);
        case 7 : return t(uint64_t_);
        case 8 : return t(int64_t_);
        case 9 : return t(bool_);
        case 10 : return t(std_string_);
        case 11 : return t(std_pair_const_u8_const_u8__);
        case 12 : return t(std_pair_const_char_const_char__);
        case 13 : return t(xml_content_);
        case 14 : return t(bcd_content_);
        case 15 : return t(int64_content_);
      }
      throw std::domain_error("variant not initialized");
    }

    template <typename T> typename T::result_type accept(const T &t) const
    {
      switch (tag_) {
        case 1 : return t(uint8_t_);
        case 2 : return t(int8_t_);
        case 3 : return t(uint16_t_);
        case 4 : return t(int16_t_);
        case 5 : return t(uint32_t_);
        case 6 : return t(int32_t_);
        case 7 : return t(uint64_t_);
        case 8 : return t(int64_t_);
        case 9 : return t(bool_);
        case 10 : return t(std_string_);
        case 11 : return t(std_pair_const_u8_const_u8__);
        case 12 : return t(std_pair_const_char_const_char__);
        case 13 : return t(xml_content_);
        case 14 : return t(bcd_content_);
        case 15 : return t(int64_content_);
      }
      throw std::domain_error("variant not initialized");
    }

};

} // xfsx



#endif
