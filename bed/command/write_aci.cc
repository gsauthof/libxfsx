// Copyright 2015, Georg Sauthoff <mail@georg.so>

/* {{{ LGPLv3

    This file is part of libxfsx.

    libxfsx is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    libxfsx is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with libxfsx.  If not, see <http://www.gnu.org/licenses/>.

}}} */

#include "write_aci.hh"

#include <xfsx/tap/traverser.hh>
#include <xfsx/traverser/tlc.hh>
#include <xfsx/xfsx.hh>
#include <xfsx/byte.hh>
#include <xfsx/lxml2ber.hh>
#include <xfsx/tap.hh>
#include <xfsx/tlc_writer.hh>
#include <bed/arguments.hh>
#include <xxxml/xxxml.hh>

#include <ixxx/util.hh>
#include <fcntl.h>

using namespace std;

using u8 = xfsx::u8;

namespace bed {

  namespace command {


    // XXX completely switch to scratchpad reader/writer
    void Write_ACI::execute()
    {
      using namespace xfsx::tap::traverser;

      auto m = ixxx::util::mmap_file(args_.in_filename);
      xfsx::Vertical_TLC tlc;

      Vertical_TLC_Proxy p(m.begin(), m.end(), tlc);

      if (p.tag(tlc) != grammar::tap::TRANSFER_BATCH)
        throw runtime_error("Format currently not supported");
      p.advance(tlc);
      const u8 *begin = tlc.begin;

      Audit_Control_Info aci;
      aci(p, tlc);

      const u8 *end = m.end();
      if (p.tag(tlc) == grammar::tap::AUDIT_CONTROL_INFO)
        end = tlc.begin;

          using namespace xfsx;
        scratchpad::Simple_Writer<char> bx(unique_ptr<scratchpad::Writer<char>>(
                    new scratchpad::Scratchpad_Writer<char>()));
        const auto &pad = dynamic_cast<scratchpad::Scratchpad_Writer<char>*>(
                bx.backend())->pad();
        byte::writer::Base b(bx);

      aci.comment = "Generated by libxfsx";
      aci.finalize();
      aci.print(b);
      bx.flush();
      auto doc = xxxml::read_memory(pad.prelude(), pad.begin(), nullptr, nullptr, 0);

      xfsx::BER_Writer_Arguments args;
      xfsx::tap::apply_grammar(args_.asn_filenames, args);

      xfsx::Unit tb;
      tb.init_constructed_from(grammar::tap::TRANSFER_BATCH);
      tb.klasse = xfsx::Klasse::APPLICATION;

      auto o = scratchpad::mk_simple_writer<u8>(args_.out_filename);
      write_tag(o, tb);
      // write takes care of incremental writing and write-through
      o.write(begin, end);
      xfsx::xml::l2::write_ber(doc, o, args);
      array<u8, 2> eoc = {0, 0};
      o.write(eoc.begin(), eoc.end());
      o.flush();
    }

  } // command

} //bed
