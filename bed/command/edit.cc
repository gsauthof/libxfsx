// Copyright 2015, Georg Sauthoff <mail@georg.so>

/* {{{ LGPLv3

    This file is part of libxfsx.

    libxfsx is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    libxfsx is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with libxfsx.  If not, see <http://www.gnu.org/licenses/>.

}}} */

#include "edit.hh"

#include <xfsx/ber2lxml.hh>
#include <xfsx/lxml2ber.hh>
#include <ixxx/util.hh>
#include <xxxml/util.hh>
#include <bed/arguments.hh>
#include "arguments.hh"
#include <xfsx/xml_writer_arguments.hh>

#include <xfsx/tap.hh>
#include <xfsx/traverser/lxml.hh>
#include <xfsx/tap/traverser.hh>
#include <xfsx/byte.hh>

#include <boost/lexical_cast.hpp>

#include <stdexcept>

using namespace std;

namespace bed {

  namespace command {

    namespace edit_op {
      struct Detail {
        const xfsx::xml::Pretty_Writer_Arguments &pretty_args;
        xxxml::doc::Ptr &doc;
        Detail(const xfsx::xml::Pretty_Writer_Arguments &pretty_args,
            xxxml::doc::Ptr &doc)
          :
            pretty_args(pretty_args),
            doc(doc)
        {}
      };
    }

    void Edit::execute()
    {
      ixxx::util::Mapped_File in(args_.in_filename);

      xfsx::xml::Pretty_Writer_Arguments pretty_args(args_.asn_filenames);
      apply_arguments(args_, pretty_args);

      xxxml::doc::Ptr doc = xfsx::xml::l2::generate_tree(in.begin(), in.end(),
          pretty_args);

      edit_op::Detail detail(pretty_args, doc);

      for (auto &edit_op : args_.edit_ops)
        edit_op->execute(detail);

      xfsx::BER_Writer_Arguments args;
      xfsx::tap::apply_grammar(args_.asn_filenames, args);

      xfsx::xml::l2::write_ber(doc, args_.out_filename, args);
    }


    namespace edit_op {

      void Remove::execute(Detail &d)
      {
        xxxml::util::remove(d.doc, argv.at(0));
      }
      void Replace::execute(Detail &d)
      {
        xxxml::util::replace(d.doc, argv.at(0), argv.at(1), argv.at(2));
      }
      void Add::execute(Detail &d)
      {
        xxxml::util::add(d.doc, argv.at(0), argv.at(1), argv.at(2));
      }
      void Set_Att::execute(Detail &d)
      {
        xxxml::util::set_attribute(d.doc, argv.at(0), argv.at(1), argv.at(2));
      }
      void Insert::execute(Detail &d)
      {
        if (!argv.at(1).empty() && argv.at(1)[0] == '@') {
          ixxx::util::Mapped_File m(argv.at(1).substr(1));
          xxxml::util::insert(d.doc, argv.at(0), m.s_begin(), m.s_end(),
              boost::lexical_cast<int>(argv.at(2)));
        } else {
          xxxml::util::insert(d.doc, argv.at(0),
              argv.at(1).data(),
              argv.at(1).data() + argv.at(1).size(),
              boost::lexical_cast<int>(argv.at(2)));
        }
      }
      void Write_ACI::execute(Detail &d)
      {
        xxxml::util::DF_Traverser t(d.doc);
        xfsx::tap::traverser::LXML_Proxy p(d.pretty_args.name_translator);
        xfsx::tap::traverser::Audit_Control_Info aci;
        aci(p, t);
        xxxml::util::remove(d.doc, "/TransferBatch/AuditControlInfo");
        xfsx::byte::writer::Memory m;
        aci.comment = "Generated by libxfsx";
        aci.print(m);
        xxxml::util::insert(d.doc, "/TransferBatch", m.begin(), m.end(), -1);
      }

    } // Edit_Op

  } // command

} //bed
